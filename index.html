<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BRX10 Real-Time Index</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root {
      --primary-color: #1a73e8;
      --secondary-color: #34a853;
      --warning-color: #fbbc05;
      --error-color: #ea4335;
      --background-color: #f8f9fa;
      --card-color: #ffffff;
      --text-color: #333333;
      --border-color: #e0e0e0;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      padding: 20px;
      background: var(--background-color);
      color: var(--text-color);
      line-height: 1.6;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    h1 {
      color: var(--primary-color);
      font-size: 2rem;
      margin-bottom: 10px;
    }

    .card {
      background: var(--card-color);
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      padding: 20px;
      margin-bottom: 20px;
    }

    .index-container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }

    .index-details {
      flex: 1;
      min-width: 300px;
    }

    #index-value {
      font-size: 2.5rem;
      font-weight: bold;
      margin: 10px 0;
      color: var(--primary-color);
    }

    #index-change {
      font-size: 1.2rem;
      font-weight: bold;
      margin-bottom: 10px;
    }

    .positive {
      color: var(--secondary-color);
    }

    .negative {
      color: var(--error-color);
    }

    .chart-container {
      flex: 2;
      min-width: 500px;
      height: 300px;
      position: relative;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
      font-size: 0.9rem;
    }

    th, td {
      padding: 12px 15px;
      border-bottom: 1px solid var(--border-color);
      text-align: left;
    }

    th {
      background-color: #f2f2f2;
      font-weight: 600;
    }

    tr:hover {
      background-color: #f5f5f5;
    }

    .buttons {
      display: flex;
      gap: 10px;
      margin: 20px 0;
    }

    button {
      background-color: var(--primary-color);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background-color 0.3s;
    }

    button:hover {
      background-color: #0d62d0;
    }

    .time-selector {
      display: flex;
      gap: 5px;
      margin-bottom: 10px;
    }

    .time-selector button {
      background-color: #f2f2f2;
      color: var(--text-color);
      font-size: 0.8rem;
      padding: 5px 10px;
    }

    .time-selector button.active {
      background-color: var(--primary-color);
      color: white;
    }

    .loading {
      position: relative;
    }

    .loading::after {
      content: "Loading...";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 1.2rem;
      color: var(--primary-color);
    }

    .last-updated {
      font-size: 0.8rem;
      color: #666;
      margin-top: 5px;
    }

    .error-message {
      background-color: #ffebee;
      color: var(--error-color);
      padding: 10px;
      border-radius: 4px;
      margin: 10px 0;
      display: none;
    }

    .config-panel {
      margin-top: 10px;
    }

    .config-panel select {
      padding: 5px;
      border-radius: 4px;
      border: 1px solid var(--border-color);
      background-color: white;
    }

    .status-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 5px;
    }

    .status-online {
      background-color: var(--secondary-color);
    }

    .status-delayed {
      background-color: var(--warning-color);
    }

    .status-offline {
      background-color: var(--error-color);
    }

    @media (max-width: 768px) {
      .chart-container {
        min-width: 100%;
      }
      
      .index-details {
        min-width: 100%;
      }
      
      th, td {
        padding: 8px 10px;
        font-size: 0.8rem;
      }
      
      .buttons {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>BRX10 Real-Time Export Index</h1>
      <div class="buttons">
        <button id="refresh-button">Refresh Data</button>
        <button id="export-csv">Export to CSV</button>
      </div>
    </header>

    <div class="error-message" id="error-display">
      Unable to fetch data. Please try again later.
    </div>
    
    <div class="card">
      <div class="index-container">
        <div class="index-details">
          <h2>Current Value</h2>
          <div id="index-value">Loading...</div>
          <div id="index-change">--</div>
          <div class="last-updated">
            <span class="status-indicator" id="status-dot"></span>
            <span id="connection-status">Connecting...</span> | 
            Last updated: <span id="last-updated-time">--</span>
          </div>
          <div class="config-panel">
            <label for="update-interval">Update interval:</label>
            <select id="update-interval">
              <option value="5000">5 seconds</option>
              <option value="15000">15 seconds</option>
              <option value="30000">30 seconds</option>
              <option value="60000">60 seconds</option>
            </select>
          </div>
        </div>
        <div class="chart-container">
          <div class="time-selector">
            <button class="time-btn active" data-time="5m">5M</button>
            <button class="time-btn" data-time="15m">15M</button>
            <button class="time-btn" data-time="30m">30M</button>
            <button class="time-btn" data-time="1h">1H</button>
          </div>
          <canvas id="chart"></canvas>
        </div>
      </div>
    </div>
    
    <div class="card">
      <h2>Component Stocks</h2>
      <table>
        <thead>
          <tr>
            <th>Company</th>
            <th>Ticker</th>
            <th>Price (R$)</th>
            <th>Change</th>
            <th>Weight</th>
          </tr>
        </thead>
        <tbody id="stock-table"></tbody>
      </table>
    </div>
  </div>

  <script>
    // Configuration
    const tickers = [
      { name: 'Vale', symbol: 'VALE3.SA', weight: 0.15 },
      { name: 'Petrobras', symbol: 'PETR4.SA', weight: 0.15 },
      { name: 'JBS', symbol: 'JBSS3.SA', weight: 0.10 },
      { name: 'BRF', symbol: 'BRFS3.SA', weight: 0.10 },
      { name: 'Suzano', symbol: 'SUZB3.SA', weight: 0.10 },
      { name: 'Embraer', symbol: 'EMBR3.SA', weight: 0.10 },
      { name: 'Ambev', symbol: 'ABEV3.SA', weight: 0.10 },
      { name: 'Gerdau', symbol: 'GGBR4.SA', weight: 0.10 },
      { name: 'Klabin', symbol: 'KLBN11.SA', weight: 0.05 },
      { name: 'Marfrig', symbol: 'MRFG3.SA', weight: 0.05 },
    ];

    // Proxy URL - REPLACE THIS WITH YOUR ACTUAL PROXY URL 
    const PROXY_URL = 'https://your-proxy-server.com/api/yahoo-finance';
    
    // State variables
    let chart;
    let historicalData = [];
    let lastIndexValue = 0;
    let currentTimeFrame = '5m';
    let updateInterval = 5000; // Default to 5 seconds
    let dataUpdateInterval = 30000; // Poll every 30 seconds as a fallback
    let lastFetchTime = 0;
    let lastData = null;
    let currentData = null;
    let updateTimer = null;
    let fetchTimer = null;
    let connectionStatus = 'connecting'; // 'online', 'delayed', 'offline'
    
    // Chart configuration
    const chartData = {
      labels: [],
      datasets: [{
        label: 'BRX10 Index',
        borderColor: '#1a73e8',
        backgroundColor: 'rgba(26, 115, 232, 0.1)',
        borderWidth: 2,
        fill: true,
        tension: 0.4,
        pointRadius: 1,
        pointHoverRadius: 5,
        data: [],
      }]
    };

    document.addEventListener('DOMContentLoaded', function() {
      setupChart();
      setupEventListeners();
      
      // Attempt to connect via WebSocket for realtime data
      setupRealtimeConnection();

      // If realtime data isn't provided quickly, fall back to polling after 5 seconds.
      setTimeout(() => {
        if (!currentData) {
          console.log("Falling back to polling mechanism.");
          fetchRealData().then(() => {
            updateUI();
            startAutomaticUpdates();
          });
        }
      }, 5000);
      
      // Initially load with dummy data if needed
      historicalData.push({
        time: new Date(),
        value: 30.0
      });
    });

    // Set up event listeners
    function setupEventListeners() {
      document.getElementById('refresh-button').addEventListener('click', () => {
        fetchRealData().then(updateUI);
      });
      
      document.getElementById('export-csv').addEventListener('click', exportToCSV);
      
      document.querySelectorAll('.time-btn').forEach(btn => {
        btn.addEventListener('click', function() {
          document.querySelectorAll('.time-btn').forEach(b => b.classList.remove('active'));
          this.classList.add('active');
          currentTimeFrame = this.dataset.time;
          updateChartDisplay();
        });
      });
      
      document.getElementById('update-interval').addEventListener('change', function() {
        updateInterval = parseInt(this.value);
        startAutomaticUpdates(); // Restart timers with new interval
      });
    }

    // Set up the chart
    function setupChart() {
      const ctx = document.getElementById('chart').getContext('2d');
      chart = new Chart(ctx, {
        type: 'line',
        data: chartData,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            tooltip: {
              mode: 'index',
              intersect: false,
              callbacks: {
                label: function(context) {
                  return `BRX10: R$ ${context.raw.toFixed(2)}`;
                }
              }
            },
            legend: {
              display: false
            }
          },
          scales: {
            x: {
              grid: {
                display: false
              },
              ticks: {
                maxTicksLimit: 8,
                maxRotation: 0
              }
            },
            y: {
              beginAtZero: false,
              ticks: {
                callback: function(value) {
                  return 'R$ ' + value.toFixed(2);
                }
              }
            }
          },
          interaction: {
            mode: 'nearest',
            axis: 'x',
            intersect: false
          }
        }
      });
    }

    // Setup realtime connection via WebSocket
    function setupRealtimeConnection() {
      const realtimeSocket = new WebSocket('wss://your-realtime-data-server.com/path');

      realtimeSocket.onopen = function() {
        console.log("WebSocket connected.");
        // Update status to online upon connection
        connectionStatus = 'online';
        updateStatusIndicator();
      };

      realtimeSocket.onmessage = function(event) {
        try {
          const realtimeData = JSON.parse(event.data);
          // Expect realtimeData to have a structure similar to the output of processApiResponse
          currentData = realtimeData;
          lastFetchTime = Date.now();
          updateUI();
        } catch (e) {
          console.error("Error parsing realtime data", e);
        }
      };

      realtimeSocket.onerror = function(error) {
        console.error("WebSocket error", error);
        // Fallback to polling if an error occurs
        startAutomaticUpdates();
      };

      realtimeSocket.onclose = function() {
        console.log("WebSocket connection closed. Falling back to polling.");
        startAutomaticUpdates();
      };
    }

    // Start automatic updates with current interval (used as a fallback for when real-time isn't available)
    function startAutomaticUpdates() {
      if (updateTimer) clearInterval(updateTimer);
      if (fetchTimer) clearInterval(fetchTimer);
      fetchTimer = setInterval(fetchRealData, dataUpdateInterval);
      updateTimer = setInterval(updateUI, updateInterval);
    }

    // Fetch real data from Yahoo Finance via proxy (fallback method)
    async function fetchRealData() {
      try {
        document.querySelector('.chart-container').classList.add('loading');
        document.querySelector('.index-details').classList.add('loading');
        document.getElementById('error-display').style.display = 'none';
        lastData = currentData;
        const symbols = tickers.map(t => t.symbol).join(',');
        const url = `${PROXY_URL}?symbols=${symbols}`;
        const response = await fetch(url);
        if (!response.ok) throw new Error('Network response was not ok');
        const data = await response.json();
        connectionStatus = 'online';
        updateStatusIndicator();
        currentData = processApiResponse(data);
        lastFetchTime = Date.now();
        return currentData;
      } catch (err) {
        console.error('Failed to fetch data', err);
        document.getElementById('error-display').style.display = 'block';
        connectionStatus = 'offline';
        updateStatusIndicator();
        return null;
      } finally {
        document.querySelector('.chart-container').classList.remove('loading');
        document.querySelector('.index-details').classList.remove('loading');
      }
    }

    // Process API response to a common format
    function processApiResponse(data) {
      if (!data || !data.quoteResponse || !data.quoteResponse.result) {
        return null;
      }
      
      const stocks = data.quoteResponse.result;
      const processed = {
        timestamp: Date.now(),
        stocks: {}
      };
      
      stocks.forEach(stock => {
        processed.stocks[stock.symbol] = {
          price: stock.regularMarketPrice,
          previousClose: stock.regularMarketPreviousClose,
          change: stock.regularMarketChange,
          changePercent: stock.regularMarketChangePercent
        };
      });
      
      return processed;
    }

    // Update UI with the latest data
    function updateUI() {
      if (!currentData) return;
      
      const now = Date.now();
      const timeSinceLastFetch = now - lastFetchTime;
      if (timeSinceLastFetch > 300000) {
        connectionStatus = 'delayed';
        updateStatusIndicator();
      }
      
      let indexTotal = 0;
      let previousIndexTotal = 0;
      
      const tbody = document.getElementById('stock-table');
      tbody.innerHTML = '';
      
      tickers.forEach(ticker => {
        const stockInfo = currentData.stocks[ticker.symbol];
        if (!stockInfo) return;
        
        const price = stockInfo.price;
        const change = stockInfo.change;
        const changePercent = stockInfo.changePercent;
        
        indexTotal += price * ticker.weight;
        previousIndexTotal += (price - change) * ticker.weight;
        
        const row = document.createElement('tr');
        const nameCell = document.createElement('td');
        nameCell.textContent = ticker.name;
        row.appendChild(nameCell);

        const tickerCell = document.createElement('td');
        tickerCell.textContent = ticker.symbol;
        row.appendChild(tickerCell);

        const priceCell = document.createElement('td');
        priceCell.textContent = `R$ ${price.toFixed(2)}`;
        row.appendChild(priceCell);

        const changeCell = document.createElement('td');
        const changeSign = change >= 0 ? '+' : '';
        changeCell.textContent = `${changeSign}${change.toFixed(2)} (${changeSign}${changePercent.toFixed(2)}%)`;
        changeCell.className = change >= 0 ? 'positive' : 'negative';
        row.appendChild(changeCell);

        const weightCell = document.createElement('td');
        weightCell.textContent = `${(ticker.weight * 100).toFixed(0)}%`;
        row.appendChild(weightCell);
        
        tbody.appendChild(row);
      });
      
      const indexValue = indexTotal;
      const indexChange = indexTotal - previousIndexTotal;
      const indexChangePercent = (indexChange / previousIndexTotal) * 100;
      
      document.getElementById('index-value').innerText = `R$ ${indexValue.toFixed(2)}`;
      const indexChangeElement = document.getElementById('index-change');
      const changeSign = indexChange >= 0 ? '+' : '';
      indexChangeElement.textContent = `${changeSign}${indexChange.toFixed(2)} (${changeSign}${indexChangePercent.toFixed(2)}%)`;
      indexChangeElement.className = indexChange >= 0 ? 'positive' : 'negative';
      
      const currentTime = new Date();
      document.getElementById('last-updated-time').textContent = currentTime.toLocaleTimeString();
      
      historicalData.push({
        time: currentTime,
        value: indexValue
      });
      
      const maxDataPoints = 17280;
      if (historicalData.length > maxDataPoints) {
        historicalData = historicalData.slice(-maxDataPoints);
      }
      
      updateChartDisplay();
      lastIndexValue = indexValue;
    }

    // Update chart display based on selected time frame
    function updateChartDisplay() {
      const timeFrames = {
        '5m': 60,
        '15m': 180,
        '30m': 360,
        '1h': 720
      };
      
      const dataPoints = Math.min(timeFrames[currentTimeFrame], historicalData.length);
      const relevantData = historicalData.slice(-dataPoints);
      
      chartData.labels = [];
      chartData.datasets[0].data = [];
      
      relevantData.forEach(point => {
        chartData.labels.push(formatTimeLabel(point.time, currentTimeFrame));
        chartData.datasets[0].data.push(point.value);
      });
      
      chart.update();
    }

    // Format time labels based on selected time frame
    function formatTimeLabel(time, timeFrame) {
      if (timeFrame === '5m' || timeFrame === '15m') {
        return time.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit'});
      } else {
        return time.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
      }
    }

    // Update the status indicator
    function updateStatusIndicator() {
      const statusDot = document.getElementById('status-dot');
      const statusText = document.getElementById('connection-status');
      statusDot.className = 'status-indicator';
      
      switch (connectionStatus) {
        case 'online':
          statusDot.classList.add('status-online');
          statusText.textContent = 'Online';
          break;
        case 'delayed':
          statusDot.classList.add('status-delayed');
          statusText.textContent = 'Delayed';
          break;
        case 'offline':
          statusDot.classList.add('status-offline');
          statusText.textContent = 'Offline';
          break;
        default:
          statusText.textContent = 'Connecting...';
      }
    }

    // Export table data to CSV
    function exportToCSV() {
      let csv = 'Company,Ticker,Price (R$),Change,Weight\n';
      const rows = document.querySelectorAll('#stock-table tr');
      rows.forEach(row => {
        const company = row.cells[0].textContent;
        const symbol = row.cells[1].textContent;
        const price = row.cells[2].textContent.replace('R$ ', '');
        const change = row.cells[3].textContent;
        const weight = row.cells[4].textContent;
        csv += `"${company}","${symbol}","${price}","${change}","${weight}"\n`;
      });
      const indexValue = document.getElementById('index-value').textContent;
      const indexChange = document.getElementById('index-change').textContent;
      csv += `\n"BRX10 Index","","${indexValue}","${indexChange}","100%"\n`;
      csv += `"Last Updated","${document.getElementById('last-updated-time').textContent}","","",""\n`;
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.setAttribute('href', url);
      link.setAttribute('download', `BRX10_Index_${new Date().toISOString().split('T')[0]}.csv`);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  </script>
</body>
</html>
